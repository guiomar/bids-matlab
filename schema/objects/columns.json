{
  "HED": {
    "name": "HED",
    "display_name": "HED Tag",
    "description": "Hierarchical Event Descriptor (HED) Tag.\nSee the [HED Appendix](SPEC_ROOT/appendices/hed.md) for details.\n",
    "type": "string"
  },
  "abbreviation": {
    "name": "abbreviation",
    "display_name": "Abbreviation",
    "description": "The unique label abbreviation\n",
    "type": "string"
  },
  "acq_time__scans": {
    "name": "acq_time",
    "display_name": "Scan acquisition time",
    "description": "Acquisition time refers to when the first data point in each run was acquired.\nFurthermore, if this header is provided, the acquisition times of all files\nfrom the same recording MUST be identical.\nDatetime format and their anonymization are described in\n[Units](SPEC_ROOT/common-principles.md#units).\n",
    "type": "string",
    "format": "datetime"
  },
  "acq_time__sessions": {
    "name": "acq_time",
    "display_name": "Session acquisition time",
    "description": "Acquisition time refers to when the first data point of the first run was acquired.\nDatetime format and their anonymization are described in\n[Units](SPEC_ROOT/common-principles.md#units).\n",
    "type": "string",
    "format": "datetime"
  },
  "age": {
    "name": "age",
    "display_name": "Subject age",
    "description": "Numeric value in years (float or integer value).\n\nIt is recommended to tag participant ages that are 89 or higher as 89+,\nfor privacy purposes.\n",
    "type": "number",
    "unit": "year"
  },
  "cardiac": {
    "name": "cardiac",
    "display_name": "Cardiac measurement",
    "description": "continuous pulse measurement\n",
    "type": "number"
  },
  "channel": {
    "name": "channel",
    "display_name": "Channel",
    "description": "Channel(s) associated with an event.\nIf multiple channels are specified, they MUST be separated by a delimiter\nspecified in the `\"Delimiter\"` field describing the `channel` column.\nFor example, channels separated with a comma (`,`) require the `events.json`\nfile to contain `\"channel\": {\"Delimiter\": \",\"}`.\nIn the absence of a delimiter, tools MUST interpret any character as being part\nof a channel name.\n",
    "type": "string"
  },
  "color": {
    "name": "color",
    "display_name": "Color label",
    "description": "Hexadecimal. Label color for visualization.\n",
    "type": "string",
    "unit": "hexadecimal"
  },
  "component": {
    "name": "component",
    "display_name": "Component",
    "description": "Description of the spatial axis or label of quaternion component associated with the channel.\nFor example, `x`,`y`,`z` for position channels,\nor `quat_x`, `quat_y`, `quat_z`, `quat_w` for quaternion orientation channels.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.x.value"
      },
      {
        "$ref": "objects.enums.y.value"
      },
      {
        "$ref": "objects.enums.z.value"
      },
      {
        "$ref": "objects.enums.quat_x.value"
      },
      {
        "$ref": "objects.enums.quat_y.value"
      },
      {
        "$ref": "objects.enums.quat_z.value"
      },
      {
        "$ref": "objects.enums.quat_w.value"
      },
      "n/a"
    ]
  },
  "detector__channels": {
    "name": "detector",
    "display_name": "Detector Name",
    "description": "Name of the detector as specified in the `*_optodes.tsv` file.\n`n/a` for channels that do not contain NIRS signals (for example, acceleration).\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "detector_type": {
    "name": "detector_type",
    "display_name": "Detector Type",
    "description": "The type of detector. Only to be used if the field `DetectorType` in `*_nirs.json` is set to `mixed`.\n",
    "anyOf": [
      {
        "type": "string"
      }
    ]
  },
  "derived_from": {
    "name": "derived_from",
    "display_name": "Derived from",
    "description": "`sample-<label>` entity from which a sample is derived,\nfor example a slice of tissue (`sample-02`) derived from a block of tissue (`sample-01`).\n",
    "type": "string",
    "pattern": "^sample-[0-9a-zA-Z]+$"
  },
  "description": {
    "name": "description",
    "display_name": "Description",
    "description": "Brief free-text description of the channel, or other information of interest.\n",
    "type": "string"
  },
  "description__optode": {
    "name": "description",
    "display_name": "Description",
    "description": "Free-form text description of the optode, or other information of interest.\n",
    "type": "string"
  },
  "dimension": {
    "name": "dimension",
    "display_name": "Dimension",
    "description": "Size of the group (grid/strip/probe) that this electrode belongs to.\nMust be of form `[AxB]` with the smallest dimension first (for example, `[1x8]`).\n",
    "type": "string"
  },
  "duration": {
    "name": "duration",
    "display_name": "Event duration",
    "description": "Duration of the event (measured from onset) in seconds.\nMust always be either zero or positive (or `n/a` if unavailable).\nA \"duration\" value of zero implies that the delta function or event is so\nshort as to be effectively modeled as an impulse.\n",
    "anyOf": [
      {
        "type": "number",
        "unit": "s",
        "minimum": 0
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "filename": {
    "name": "filename",
    "display_name": "Filename",
    "description": "Relative paths to files.\n",
    "type": "string",
    "format": "participant_relative"
  },
  "group__channel": {
    "name": "group",
    "display_name": "Channel group",
    "description": "Which group of channels (grid/strip/seeg/depth) this channel belongs to.\nThis is relevant because one group has one cable-bundle and noise can be shared.\nThis can be a name or number.\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "number"
      }
    ]
  },
  "handedness": {
    "name": "handedness",
    "display_name": "Subject handedness",
    "description": "String value indicating one of \"left\", \"right\", \"ambidextrous\".\n\nFor \"left\", use one of these values: `left`, `l`, `L`, `LEFT`, `Left`.\n\nFor \"right\", use one of these values: `right`, `r`, `R`, `RIGHT`, `Right`.\n\nFor \"ambidextrous\", use one of these values: `ambidextrous`, `a`, `A`, `AMBIDEXTROUS`,\n`Ambidextrous`.\n",
    "type": "string",
    "enum": [
      "left",
      "l",
      "L",
      "LEFT",
      "Left",
      "right",
      "r",
      "R",
      "RIGHT",
      "Right",
      "ambidextrous",
      "a",
      "A",
      "AMBIDEXTROUS",
      "Ambidextrous",
      "n/a"
    ]
  },
  "hemisphere": {
    "name": "hemisphere",
    "display_name": "Electrode hemisphere",
    "description": "The hemisphere in which the electrode is placed.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.left_hemisphere.value"
      },
      {
        "$ref": "objects.enums.right_hemisphere.value"
      }
    ]
  },
  "high_cutoff": {
    "name": "high_cutoff",
    "display_name": "High cutoff",
    "description": "Frequencies used for the low-pass filter applied to the channel in Hz.\nIf no low-pass filter applied, use `n/a`.\nNote that hardware anti-aliasing in A/D conversion of all MEG/EEG electronics\napplies a low-pass filter; specify its frequency here if applicable.\n",
    "anyOf": [
      {
        "type": "number",
        "unit": "Hz",
        "minimum": 0
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "hplc_recovery_fractions": {
    "name": "hplc_recovery_fractions",
    "display_name": "HPLC recovery fractions",
    "description": "HPLC recovery fractions (the fraction of activity that gets loaded onto the HPLC).\n",
    "type": "number",
    "unit": "arbitrary"
  },
  "impedance": {
    "name": "impedance",
    "display_name": "Electrode impedance",
    "description": "Impedance of the electrode, units MUST be in `kOhm`.\n",
    "type": "number",
    "unit": "kOhm"
  },
  "index": {
    "name": "index",
    "display_name": "Label index",
    "description": "The label integer index.\n",
    "type": "integer"
  },
  "low_cutoff": {
    "name": "low_cutoff",
    "display_name": "Low cutoff",
    "description": "Frequencies used for the high-pass filter applied to the channel in Hz.\nIf no high-pass filter applied, use `n/a`.\n",
    "anyOf": [
      {
        "type": "number",
        "unit": "Hz"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "manufacturer": {
    "name": "manufacturer",
    "display_name": "Manufacturer",
    "description": "The manufacturer for each electrode.\nCan be used if electrodes were manufactured by more than one company.\n",
    "type": "string"
  },
  "mapping": {
    "name": "mapping",
    "display_name": "Label mapping",
    "description": "Corresponding integer label in the standard BIDS label lookup.\n",
    "type": "integer"
  },
  "material": {
    "name": "material",
    "display_name": "Electrode material",
    "description": "Material of the electrode (for example, `Tin`, `Ag/AgCl`, `Gold`).\n",
    "type": "string"
  },
  "metabolite_parent_fraction": {
    "name": "metabolite_parent_fraction",
    "display_name": "Metabolite parent fraction",
    "description": "Parent fraction of the radiotracer (0-1).\n",
    "type": "number",
    "minimum": 0,
    "maximum": 1
  },
  "metabolite_polar_fraction": {
    "name": "metabolite_polar_fraction",
    "display_name": "Metabolite polar fraction",
    "description": "Polar metabolite fraction of the radiotracer (0-1).\n",
    "type": "number",
    "minimum": 0,
    "maximum": 1
  },
  "name__channels": {
    "name": "name",
    "display_name": "Channel name",
    "description": "Label of the channel.\n",
    "type": "string"
  },
  "name__electrodes": {
    "name": "name",
    "display_name": "Electrode name",
    "description": "Name of the electrode contact point.\n",
    "type": "string"
  },
  "name__optodes": {
    "name": "name",
    "display_name": "Optode name",
    "description": "Name of the optode, must be unique.\n",
    "type": "string"
  },
  "name__segmentations": {
    "name": "name",
    "display_name": "Label name",
    "description": "The unique label name.\n",
    "type": "string"
  },
  "notch": {
    "name": "notch",
    "display_name": "Notch frequencies",
    "description": "Frequencies used for the notch filter applied to the channel, in Hz.\nIf notch filters are applied at multiple frequencies,\nthese frequencies MAY be specified as a list,\nfor example, `[60, 120, 180]`.\nIf no notch filter was applied, use `n/a`.\n",
    "type": "string"
  },
  "onset": {
    "name": "onset",
    "display_name": "Event onset",
    "description": "Onset (in seconds) of the event, measured from the beginning of the acquisition\nof the first data point stored in the corresponding task data file.\nNegative onsets are allowed, to account for events that occur prior to the first\nstored data point.\nFor example, in case there is an in-scanner training phase that begins before\nthe scanning sequence has started events from this sequence should have\nnegative onset time counting down to the beginning of the acquisition of the\nfirst volume.\n\nIf any data points have been discarded before forming the data file\n(for example, \"dummy volumes\" in BOLD fMRI),\na time of 0 corresponds to the first stored data point and not the first\nacquired data point.\n",
    "type": "number",
    "unit": "s"
  },
  "pathology": {
    "name": "pathology",
    "display_name": "Pathology",
    "description": "String value describing the pathology of the sample or type of control.\nWhen different from `healthy`, pathology SHOULD be specified.\nThe pathology may be specified in either `samples.tsv` or\n`sessions.tsv`, depending on whether the pathology changes over time.\n",
    "type": "string"
  },
  "participant_id": {
    "name": "participant_id",
    "display_name": "Participant ID",
    "description": "A participant identifier of the form `sub-<label>`,\nmatching a participant entity found in the dataset.\n",
    "type": "string",
    "pattern": "^sub-[0-9a-zA-Z]+$"
  },
  "placement__motion": {
    "name": "placement",
    "display_name": "Placement",
    "description": "Placement of the tracked point on the body (for example,\nparticipant, avatar centroid, torso, left arm).\nIt can refer to an external vocabulary for describing body parts.\n",
    "type": "string"
  },
  "plasma_radioactivity": {
    "name": "plasma_radioactivity",
    "display_name": "Plasma radioactivity",
    "description": "Radioactivity in plasma, in unit of plasma radioactivity (for example, `kBq/mL`).\n",
    "type": "number"
  },
  "reference__eeg": {
    "name": "reference",
    "display_name": "Electrode reference",
    "description": "Name of the reference electrode(s).\nThis column is not needed when it is common to all channels.\nIn that case the reference electrode(s) can be specified in `*_eeg.json` as `EEGReference`).\n",
    "type": "string"
  },
  "reference__ieeg": {
    "name": "reference",
    "display_name": "Electrode reference",
    "description": "Specification of the reference (for example, `mastoid`, `ElectrodeName01`, `intracranial`, `CAR`, `other`, `n/a`).\nIf the channel is not an electrode channel (for example, a microphone channel) use `n/a`.\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "reference_frame": {
    "name": "reference_frame",
    "display_name": "Reference frame",
    "description": "Specification of a reference frame in which the motion data are to be interpreted.\nThe description of the levels in `*_channels.json` SHOULD use `RotationRule`,\n`RotationOrder`, and `SpatialAxis`, and MAY use `Description` for the specification.\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "respiratory": {
    "name": "respiratory",
    "display_name": "Respiratory measurement",
    "description": "continuous breathing measurement\n",
    "type": "number"
  },
  "response_time": {
    "name": "response_time",
    "display_name": "Response time",
    "description": "Response time measured in seconds.\nA negative response time can be used to represent preemptive responses and\n`n/a` denotes a missed response.\n",
    "anyOf": [
      {
        "type": "number",
        "unit": "s"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "sample_id": {
    "name": "sample_id",
    "display_name": "Sample ID",
    "description": "A sample identifier of the form `sample-<label>`,\nmatching a sample entity found in the dataset.\n",
    "type": "string",
    "pattern": "^sample-[0-9a-zA-Z]+$"
  },
  "sample_type": {
    "name": "sample_type",
    "display_name": "Sample type",
    "description": "Biosample type defined by\n[ENCODE Biosample Type](https://www.encodeproject.org/profiles/biosample_type).\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.cell_line.value"
      },
      {
        "$ref": "objects.enums.in_vitro_differentiated_cells.value"
      },
      {
        "$ref": "objects.enums.primary_cell.value"
      },
      {
        "$ref": "objects.enums.cell_free_sample.value"
      },
      {
        "$ref": "objects.enums.cloning_host.value"
      },
      {
        "$ref": "objects.enums.tissue.value"
      },
      {
        "$ref": "objects.enums.whole_organisms.value"
      },
      {
        "$ref": "objects.enums.organoid.value"
      },
      {
        "$ref": "objects.enums.technical_sample.value"
      }
    ]
  },
  "sampling_frequency": {
    "name": "sampling_frequency",
    "display_name": "Channel sampling frequency",
    "description": "Sampling rate of the channel in Hz.\n",
    "type": "number",
    "unit": "Hz"
  },
  "session_id": {
    "name": "session_id",
    "display_name": "Session ID",
    "description": "A session identifier of the form `ses-<label>`,\nmatching a session found in the dataset.\n",
    "type": "string",
    "pattern": "^ses-[0-9a-zA-Z]+$"
  },
  "sex": {
    "name": "sex",
    "display_name": "Sex",
    "description": "String value indicating phenotypical sex, one of \"male\", \"female\", \"other\".\n\nFor \"male\", use one of these values: `male`, `m`, `M`, `MALE`, `Male`.\n\nFor \"female\", use one of these values: `female`, `f`, `F`, `FEMALE`, `Female`.\n\nFor \"other\", use one of these values: `other`, `o`, `O`, `OTHER`, `Other`.\n",
    "type": "string",
    "enum": [
      "male",
      "m",
      "M",
      "MALE",
      "Male",
      "female",
      "f",
      "F",
      "FEMALE",
      "Female",
      "other",
      "o",
      "O",
      "OTHER",
      "Other",
      "n/a"
    ]
  },
  "short_channel": {
    "name": "short_channel",
    "display_name": "Short Channel",
    "description": "Is the channel designated as short.\nThe total number of channels listed as short channels\nSHOULD be stored in `ShortChannelCount` in `*_nirs.json`.\n",
    "type": "boolean"
  },
  "size": {
    "name": "size",
    "display_name": "Electrode size",
    "description": "Surface area of the electrode, units MUST be in `mm^2`.\n",
    "type": "number",
    "unit": "mm^2"
  },
  "software_filters": {
    "name": "software_filters",
    "display_name": "Software filters",
    "description": "List of temporal and/or spatial software filters applied\n(for example, `SSS`, `SpatialCompensation`).\nNote that parameters should be defined in the general MEG sidecar .json file.\nIndicate `n/a` in the absence of software filters applied.\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "source__channels": {
    "name": "source",
    "display_name": "Source name",
    "description": "Name of the source as specified in the `*_optodes.tsv` file.\n`n/a` for channels that do not contain fNIRS signals (for example, acceleration).\n",
    "anyOf": [
      {
        "type": "string"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "source__optodes": {
    "name": "source_type",
    "display_name": "Source type",
    "description": "The type of source. Only to be used if the field `SourceType` in `*_nirs.json` is set to `mixed`.\n",
    "anyOf": [
      {
        "type": "string"
      }
    ]
  },
  "species": {
    "name": "species",
    "display_name": "Species",
    "description": "The `species` column SHOULD be a binomial species name from the\n[NCBI Taxonomy](https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi)\n(for example, `homo sapiens`, `mus musculus`, `rattus norvegicus`).\nFor backwards compatibility, if `species` is absent, the participant is assumed to be\n`homo sapiens`.\n",
    "type": "string"
  },
  "status": {
    "name": "status",
    "display_name": "Channel status",
    "description": "Data quality observed on the channel.\nA channel is considered `bad` if its data quality is compromised by excessive noise.\nIf quality is unknown, then a value of `n/a` may be used.\nDescription of noise type SHOULD be provided in `[status_description]`.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.good.value"
      },
      {
        "$ref": "objects.enums.bad.value"
      },
      "n/a"
    ]
  },
  "status_description": {
    "name": "status_description",
    "display_name": "Channel status description",
    "description": "Freeform text description of noise or artifact affecting data quality on the channel.\nIt is meant to explain why the channel was declared bad in the `status` column.\n",
    "type": "string"
  },
  "stim_file": {
    "name": "stim_file",
    "display_name": "Stimulus file",
    "description": "Represents the location of the stimulus file (such as an image, video, or\naudio file) presented at the given onset time.\nThere are no restrictions on the file formats of the stimuli files,\nbut they should be stored in the `/stimuli` directory\n(under the root directory of the dataset; with optional subdirectories).\nThe values under the `stim_file` column correspond to a path relative to\n`/stimuli`.\nFor example `images/cat03.jpg` will be translated to `/stimuli/images/cat03.jpg`.\n",
    "type": "string",
    "format": "stimuli_relative"
  },
  "strain": {
    "name": "strain",
    "display_name": "Strain",
    "description": "For species different from `homo sapiens`, string value indicating\nthe strain of the species, for example: `C57BL/6J`.\n",
    "type": "string"
  },
  "strain_rrid": {
    "name": "strain_rrid",
    "display_name": "Strain RRID",
    "description": "For species different from `homo sapiens`, research resource identifier\n([RRID](https://scicrunch.org/resources/data/source/nlx_154697-1/search))\nof the strain of the species, for example: `RRID:IMSR_JAX:000664`.\n",
    "type": "string",
    "format": "rrid"
  },
  "time": {
    "name": "time",
    "display_name": "Time",
    "description": "Time, in seconds, relative to `TimeZero` defined by the `*_pet.json`.\nFor example, 5.\n",
    "type": "number",
    "unit": "s"
  },
  "tracked_point__channels": {
    "name": "tracked_point",
    "display_name": "Tracked point channel",
    "description": "Label of the point that is being tracked, for example, label of a tracker\nor a marker (for example,`\"LeftFoot\"`, `\"RightWrist\"`).\n",
    "type": "string"
  },
  "trial_type": {
    "name": "trial_type",
    "display_name": "Trial type",
    "description": "Primary categorisation of each trial to identify them as instances of the\nexperimental conditions.\nFor example: for a response inhibition task, it could take on values `go` and\n`no-go` to refer to response initiation and response inhibition experimental\nconditions.\n",
    "type": "string"
  },
  "trigger": {
    "name": "trigger",
    "display_name": "Trigger",
    "description": "continuous measurement of the scanner trigger signal\n",
    "type": "number"
  },
  "type__channels": {
    "name": "type",
    "display_name": "Channel type",
    "description": "Type of channel; MUST use the channel types listed below.\nNote that the type MUST be in upper-case.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.ACCEL.value"
      },
      {
        "$ref": "objects.enums.ADC.value"
      },
      {
        "$ref": "objects.enums.ANGACCEL.value"
      },
      {
        "$ref": "objects.enums.AUDIO.value"
      },
      {
        "$ref": "objects.enums.DAC.value"
      },
      {
        "$ref": "objects.enums.DBS.value"
      },
      {
        "$ref": "objects.enums.ECG.value"
      },
      {
        "$ref": "objects.enums.ECOG.value"
      },
      {
        "$ref": "objects.enums.EEG.value"
      },
      {
        "$ref": "objects.enums.EMG.value"
      },
      {
        "$ref": "objects.enums.EOG.value"
      },
      {
        "$ref": "objects.enums.EYEGAZE.value"
      },
      {
        "$ref": "objects.enums.FITERR.value"
      },
      {
        "$ref": "objects.enums.GSR.value"
      },
      {
        "$ref": "objects.enums.GYRO.value"
      },
      {
        "$ref": "objects.enums.HEOG.value"
      },
      {
        "$ref": "objects.enums.HLU.value"
      },
      {
        "$ref": "objects.enums.JNTANG.value"
      },
      {
        "$ref": "objects.enums.LATENCY.value"
      },
      {
        "$ref": "objects.enums.MAGN.value"
      },
      {
        "$ref": "objects.enums.MEGGRADAXIAL.value"
      },
      {
        "$ref": "objects.enums.MEGGRADPLANAR.value"
      },
      {
        "$ref": "objects.enums.MEGMAG.value"
      },
      {
        "$ref": "objects.enums.MEGOTHER.value"
      },
      {
        "$ref": "objects.enums.MEGREFGRADAXIAL.value"
      },
      {
        "$ref": "objects.enums.MEGREFGRADPLANAR.value"
      },
      {
        "$ref": "objects.enums.MEGREFMAG.value"
      },
      {
        "$ref": "objects.enums.MISC.value"
      },
      {
        "$ref": "objects.enums.NIRSCWAMPLITUDE.value"
      },
      {
        "$ref": "objects.enums.NIRSCWFLUORESCENSEAMPLITUDE.value"
      },
      {
        "$ref": "objects.enums.NIRSCWHBO.value"
      },
      {
        "$ref": "objects.enums.NIRSCWHBR.value"
      },
      {
        "$ref": "objects.enums.NIRSCWMUA.value"
      },
      {
        "$ref": "objects.enums.NIRSCWOPTICALDENSITY.value"
      },
      {
        "$ref": "objects.enums.ORNT.value"
      },
      {
        "$ref": "objects.enums.OTHER.value"
      },
      {
        "$ref": "objects.enums.PD.value"
      },
      {
        "$ref": "objects.enums.POS.value"
      },
      {
        "$ref": "objects.enums.PPG.value"
      },
      {
        "$ref": "objects.enums.PUPIL.value"
      },
      {
        "$ref": "objects.enums.REF.value"
      },
      {
        "$ref": "objects.enums.RESP.value"
      },
      {
        "$ref": "objects.enums.SEEG.value"
      },
      {
        "$ref": "objects.enums.SYSCLOCK.value"
      },
      {
        "$ref": "objects.enums.TEMP.value"
      },
      {
        "$ref": "objects.enums.TRIG.value"
      },
      {
        "$ref": "objects.enums.VEL.value"
      },
      {
        "$ref": "objects.enums.VEOG.value"
      }
    ]
  },
  "type__electrodes": {
    "name": "type",
    "display_name": "Electrode type",
    "description": "Type of the electrode (for example, cup, ring, clip-on, wire, needle).\n",
    "type": "string"
  },
  "type__optodes": {
    "name": "type",
    "display_name": "Type",
    "description": "The type of the optode.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.source.value"
      },
      {
        "$ref": "objects.enums.detector.value"
      },
      "n/a"
    ]
  },
  "units": {
    "name": "units",
    "display_name": "Units",
    "description": "Physical unit of the value represented in this channel,\nfor example, `V` for Volt, or `fT/cm` for femto Tesla per centimeter\n(see [Units](SPEC_ROOT/common-principles.md#units)).\n",
    "type": "string",
    "format": "unit"
  },
  "units__nirs": {
    "name": "units",
    "display_name": "Units",
    "description": "Physical unit of the value represented in this channel,\nspecified according to the SI unit symbol and possibly prefix symbol,\nor as a derived SI unit (for example, `V`, or unitless for changes in optical densities).\nFor guidelines about units see the [Appendix](SPEC_ROOT/appendices/units.md)\nand [Common Principles](SPEC_ROOT/common-principles.md#units) pages.\n",
    "type": "string",
    "format": "unit"
  },
  "units__motion": {
    "name": "units",
    "display_name": "Units",
    "description": "Physical or virtual unit of the value represented in this channel,\nfor example, '\"rad\"' or '\"deg\"' for angular quantities or '\"m\"' for position data.\nIf motion data is recorded in a virtual space and deviate from standard SI units,\nthe unit used MUST be specified in the sidecar `*_motion.json`\nfile (for example `\"vm\"` for virtual meters). `\"rad\"` is used for Euler angles\nand `\"n/a\"` for quaternions.\nFor guidelines about units see the [Appendix](SPEC_ROOT/appendices/units.md)\nand [Common Principles](SPEC_ROOT/common-principles.md#units) pages.\n",
    "type": "string",
    "format": "unit"
  },
  "volume_type": {
    "name": "volume_type",
    "display_name": "ASL volume type",
    "description": "The `*_aslcontext.tsv` table consists of a single column of labels identifying\nthe `volume_type` of each volume in the corresponding `*_asl.nii[.gz]` file.\n",
    "type": "string",
    "enum": [
      {
        "$ref": "objects.enums.control.value"
      },
      {
        "$ref": "objects.enums.label.value"
      },
      {
        "$ref": "objects.enums.m0scan.value"
      },
      {
        "$ref": "objects.enums.deltam.value"
      },
      {
        "$ref": "objects.enums.cbf.value"
      }
    ]
  },
  "wavelength_nominal": {
    "name": "wavelength_nominal",
    "display_name": "Wavelength nominal",
    "description": "Specified wavelength of light in nm.\n`n/a` for channels that do not contain raw NIRS signals (for example, acceleration).\nThis field is equivalent to `/nirs(i)/probe/wavelengths` in the SNIRF specification.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "wavelength_actual": {
    "name": "wavelength_actual",
    "display_name": "Wavelength actual",
    "description": "Measured wavelength of light in nm.\n`n/a` for channels that do not contain raw NIRS signals (acceleration).\nThis field is equivalent to `measurementList.wavelengthActual` in the SNIRF specification.\n",
    "type": "number"
  },
  "wavelength_emission_actual": {
    "name": "wavelength_emission_actual",
    "display_name": "Wavelength emission actual",
    "description": "Measured emission wavelength of light in nm.\n`n/a` for channels that do not contain raw NIRS signals (acceleration).\nThis field is equivalent to `measurementList.wavelengthEmissionActual` in the SNIRF specification.\n",
    "type": "number"
  },
  "whole_blood_radioactivity": {
    "name": "whole_blood_radioactivity",
    "display_name": "Whole blood radioactivity",
    "description": "Radioactivity in whole blood samples,\nin unit of radioactivity measurements in whole blood samples (for example, `kBq/mL`).\n",
    "type": "number"
  },
  "x": {
    "name": "x",
    "display_name": "X position",
    "description": "Recorded position along the x-axis.\n",
    "type": "number"
  },
  "y": {
    "name": "y",
    "display_name": "Y position",
    "description": "Recorded position along the y-axis.\n",
    "type": "number"
  },
  "z": {
    "name": "z",
    "display_name": "Z position",
    "description": "Recorded position along the z-axis.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "x__optodes": {
    "name": "x",
    "display_name": "X position",
    "description": "Recorded position along the x-axis.\n`\"n/a\"` if not available.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "y__optodes": {
    "name": "y",
    "display_name": "Y position",
    "description": "Recorded position along the y-axis.\n`\"n/a\"` if not available.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "z__optodes": {
    "name": "z",
    "display_name": "Z position",
    "description": "Recorded position along the z-axis.\n`\"n/a\"` if not available.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "template_x": {
    "name": "template_x",
    "display_name": "X template position",
    "description": "Assumed or ideal position along the x axis.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "template_y": {
    "name": "template_y",
    "display_name": "Y template position",
    "description": "Assumed or ideal position along the y axis.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  },
  "template_z": {
    "name": "template_z",
    "display_name": "Z template position",
    "description": "Assumed or ideal position along the z axis.\n",
    "anyOf": [
      {
        "type": "number"
      },
      {
        "type": "string",
        "enum": [
          "n/a"
        ]
      }
    ]
  }
}